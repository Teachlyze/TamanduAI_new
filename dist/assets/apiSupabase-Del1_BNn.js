import{s as i}from"./main-NgjJy_CG.js";const _=async(e,t,r,s="read")=>{try{const{data:{session:a}}=await i.auth.getSession();if(!a?.user)throw new Error("Usuário não autenticado");switch(e){case"class":{const{data:o,error:n}=await i.from("classes").select("created_by, id").eq("id",t).single();if(n)throw n;if(s==="write"){if(o.created_by!==r)throw new Error("Apenas o professor pode modificar esta turma")}else{if(o.created_by===r)return!0;const{data:c}=await i.from("class_members").select("id").eq("class_id",t).eq("user_id",r).eq("role","student").single();if(!c)throw new Error("Você não tem acesso a esta turma")}break}case"activity":{const{data:o,error:n}=await i.from("activities").select(`
            id,
            created_by
          `).eq("id",t).single();if(n)throw n;if(o.created_by===r)return!0;const{data:c}=await i.from("activity_class_assignments").select("class_id").eq("activity_id",t);if(c&&c.length>0){const l=c.map(w=>w.class_id),{data:d}=await i.from("classes").select("id").in("id",l).eq("created_by",r);if(d&&d.length>0)return!0;const{data:u}=await i.from("class_members").select("id").in("class_id",l).eq("user_id",r).eq("role","student");if(u&&u.length>0)return!0}throw new Error("Você não tem acesso a esta atividade")}case"submission":{const{data:o,error:n}=await i.from("submissions").select("student_id").eq("id",t).single();if(n)throw n;if(o.student_id!==r)throw new Error("Você só pode acessar suas próprias submissões");break}default:throw new Error(`Tipo de recurso não suportado: ${e}`)}return!0}catch(a){throw console.error("Erro na validação de acesso:",a),a}},h=async(e,t,r="read")=>_("class",e,t,r),y=async(e,t,r="read")=>_("activity",e,t,r),g=3,b=1e3,p=5*60*1e3,m=new Map,E=e=>new Promise(t=>setTimeout(t,e)),v=async(e,t=g)=>{for(let r=0;r<t;r++)try{return await e()}catch(s){if(r===t-1||!(s.message?.includes("network")||s.message?.includes("timeout")||s.message?.includes("temporarily")))throw s;await E(b*(r+1))}},A=e=>{const t=m.get(e);return t&&Date.now()-t.timestamp<p?t.data:(m.delete(e),null)},q=(e,t)=>{m.set(e,{data:t,timestamp:Date.now()})},f=async()=>{try{const{data:{user:e},error:t}=await i.auth.getUser();if(t)return console.warn("Error getting current user:",t.message),null;if(!e){const{data:{session:r},error:s}=await i.auth.getSession();return s?(console.warn("Error getting session:",s.message),null):r?.user||null}return e}catch(e){return console.error("Unexpected error in getCurrentUser:",e),null}},x=async e=>{if(!e)throw new Error("Class ID is required");const t=await f();if(!t)throw new Error("Usuário não autenticado");await h(e,t.id,"read");const r=`class_export_${e}_${t.id}`,s=A(r);if(s)return s;try{return await v(async()=>{const{data:a,error:o}=await i.from("classes").select("id, name, subject, created_by, created_at").eq("id",e).single();if(o)throw o;if(!a)throw new Error("Turma não encontrada");const{data:n,error:c}=await i.from("class_members").select(`
          student:profiles (
            id,
            full_name,
            avatar_url,
            created_at
          )
        `).eq("class_id",e).eq("role","student");if(c)throw c;const{data:l,error:d}=await i.from("activities").select(`
            id,
            title,
            activity_type,
            created_at,
            due_date,
            status,
            created_by
          `).in("id",activityIds).order("created_at",{ascending:!1});if(d)throw d;const u={class:{id:a.id,name:a.name,subject:a.subject,created_at:a.created_at},students:n?.map(w=>w.student).filter(Boolean)||[],activities:l||[],exported_at:new Date().toISOString(),exported_by:t.id};return q(r,u),u})}catch(a){throw console.error("Error exporting class data:",a),new Error("Falha ao exportar dados da turma: "+a.message)}},C=async e=>{const t=await f();if(!t)throw new Error("Usuário não autenticado");const{data:r,error:s}=await i.from("activities").select("id, title, description, instructions, schema, status, created_by, created_at, updated_at, due_date, total_points").eq("id",e).or(`created_by.eq.${t.id},status.eq.published`).single();if(s)throw s;return r},R=async({activity_id:e,answers:t,hcaptchaToken:r})=>{const s=await f();if(!s)throw new Error("Usuário não autenticado");await y(e,s.id,"read");try{const{data:a,error:o}=await i.from("submissions").insert({student_id:s.id,activity_id:e,data:t??null,submitted_at:new Date().toISOString()}).select("id, student_id, activity_id, submitted_at, status").single();if(o)throw console.error("Error submitting activity:",o.message),o;return a}catch(a){throw console.error("Error in submitActivity:",a),a}},U=C;export{U as a,x as e,f as g,R as s};
