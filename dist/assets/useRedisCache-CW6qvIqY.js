import{af as i,s as U,r as h}from"./main-Bujpyeg-.js";const Y="false".toLowerCase()==="true";class V{constructor(){this.metrics={cache:{hits:0,misses:0,errors:0,sets:0,deletes:0,stale:0,invalidations:0},api:{calls:0,errors:0,latency:[],byEndpoint:{}},auth:{login:{success:0,errors:0},sessionChecks:0,permissionChecks:0,tokenRefreshes:0,tokenErrors:0},performance:{pageLoad:[],apiCall:[],render:[]},errors:[]},this.initialized=!1,this.pageLoadStart=Date.now(),this.init()}init(){this.initialized||typeof window>"u"||(this.interval=setInterval(()=>this.logMetrics(),5*60*1e3),this.initialized=!0,window.addEventListener("load",()=>{const e=Date.now()-this.pageLoadStart;this.recordPageLoad(e)}),window.addEventListener("beforeunload",()=>this.logMetrics()),this.setupErrorHandling(),this.setupPerformanceMonitoring())}setupErrorHandling(){window.onerror=(e,s,t,a,c)=>(this.trackError({type:"unhandled_error",message:c?.message||e,stack:c?.stack,source:s,lineno:t,colno:a}),!1),window.addEventListener("unhandledrejection",e=>{this.trackError({type:"unhandled_rejection",message:e.reason?.message||"Unhandled promise rejection",stack:e.reason?.stack})})}setupPerformanceMonitoring(){if(!window.performance)return;const e=performance.getEntriesByType("navigation")[0];if(e){const{domComplete:t,loadEventEnd:a,domInteractive:c,domContentLoadedEventEnd:o}=e;this.recordPageLoad(a),i.info("Page load metrics",{domLoad:t,pageLoad:a,domInteractive:c,domContentLoaded:o})}performance.getEntriesByType("resource").forEach(t=>{i.debug("Resource loaded",{name:t.name,duration:t.duration,initiatorType:t.initiatorType,transferSize:t.transferSize})})}recordPageLoad(e){return this.metrics.performance.pageLoad.push(e),this.metrics.performance.pageLoad.length>100&&this.metrics.performance.pageLoad.shift(),e}apiCall(e,s,t={}){this.metrics.api.calls++,this.metrics.api.latency.push(s),this.metrics.api.byEndpoint[e]||(this.metrics.api.byEndpoint[e]={calls:0,errors:0,totalLatency:0,avgLatency:0});const a=this.metrics.api.byEndpoint[e];return a.calls++,a.totalLatency+=s,a.avgLatency=a.totalLatency/a.calls,i.info("API Call",{endpoint:e,duration:s,...t}),s}apiError(e,s){return this.metrics.api.errors++,this.metrics.api.byEndpoint[e]&&this.metrics.api.byEndpoint[e].errors++,this.trackError({type:"api_error",endpoint:e,message:s?.message||"Unknown API error",stack:s?.stack,status:s?.status,code:s?.code}),s}trackError(e){const s=new Date().toISOString(),t={...e,timestamp:s,userAgent:navigator?.userAgent,url:window.location?.href};return this.metrics.errors.push(t),this.metrics.errors.length>100&&this.metrics.errors.shift(),i.error("Error occurred",t),t}cacheHit(e){return this.metrics.cache.hits++,i.debug("Cache hit",{endpoint:e}),this.metrics.cache.hits}cacheMiss(e){return this.metrics.cache.misses++,i.debug("Cache miss",{endpoint:e}),this.metrics.cache.misses}cacheStale(e){return this.metrics.cache.stale++,i.debug("Cache stale",{endpoint:e}),this.metrics.cache.stale}cacheError(e){return this.metrics.cache.errors++,this.trackError({type:"cache_error",message:e?.message||"Cache error",stack:e?.stack}),this.metrics.cache.errors}cacheSet(e){return this.metrics.cache.sets++,i.debug("Cache set",{key:e}),this.metrics.cache.sets}cacheDelete(e){return this.metrics.cache.deletes++,i.debug("Cache delete",{key:e}),this.metrics.cache.deletes}cacheInvalidate(e){return this.metrics.cache.invalidations++,i.debug("Cache invalidate",{pattern:e}),this.metrics.cache.invalidations}loginSuccess(){return this.metrics.auth.login.success++,this.metrics.auth.login.success}loginError(){return this.metrics.auth.login.errors++,this.metrics.auth.login.errors}sessionCheck(){return this.metrics.auth.sessionChecks++,this.metrics.auth.sessionChecks}permissionCheck(){return this.metrics.auth.permissionChecks++,this.metrics.auth.permissionChecks}async logMetrics(){try{if(!this.initialized)return;const e=new Date().toISOString(),s={...this.metrics,timestamp:e,pageUrl:window.location?.href,userAgent:navigator?.userAgent};if(Y&&U){const{error:t}=await U.from("metrics").insert([s]);t?i.error("Error saving metrics to Supabase",{error:t}):i.info("Metrics logged successfully")}return this.resetCounters(),s}catch(e){return i.error("Error in metrics logging",{error:e}),null}}resetCounters(){this.metrics.cache.hits=0,this.metrics.cache.misses=0,this.metrics.cache.errors=0,this.metrics.cache.sets=0,this.metrics.cache.deletes=0,this.metrics.cache.stale=0,this.metrics.cache.invalidations=0,this.metrics.api.calls=0,this.metrics.api.errors=0,this.metrics.api.latency=[],this.metrics.auth.login.success=0,this.metrics.auth.login.errors=0,this.metrics.auth.sessionChecks=0,this.metrics.auth.permissionChecks=0}getMetrics(){return{...this.metrics}}}const E=new V;typeof window<"u"&&E.init();const X=typeof window<"u",G="https://wapbwaimkurbuihatmix.supabase.co/functions/v1/redis-cache";class H{constructor(){this.cache=new Map,this.timeouts=new Map}async get(e,s=!0){const t=this.cache.get(e);if(!t)return null;const{data:a,expiresAt:c}=t;return c&&Date.now()>c?(this.cache.delete(e),null):s&&typeof a=="string"?JSON.parse(a):a}async set(e,s,t=300){const a=typeof s=="string"?s:JSON.stringify(s),c=t?Date.now()+t*1e3:null;if(this.cache.set(e,{data:a,expiresAt:c}),t){this.timeouts.has(e)&&clearTimeout(this.timeouts.get(e));const o=setTimeout(()=>{this.cache.delete(e),this.timeouts.delete(e)},t*1e3);this.timeouts.set(e,o)}return!0}async del(e){return this.timeouts.has(e)&&(clearTimeout(this.timeouts.get(e)),this.timeouts.delete(e)),this.cache.delete(e)}async deletePattern(e){const s=new RegExp(e.replace(/\*/g,".*"));let t=0;for(const a of this.cache.keys())s.test(a)&&(await this.del(a),t++);return t}async clear(){return this.cache.clear(),this.timeouts.forEach(clearTimeout),this.timeouts.clear(),!0}async healthCheck(){return{status:"healthy",message:"Using browser in-memory cache",timestamp:new Date().toISOString()}}async getStats(){return{connected:!0,mode:"browser",stats:{keys:this.cache.size,memoryUsage:0,uptime:0}}}}class K extends H{constructor(){super(),this.edgeFunctionUrl=G,this.enabled=!!this.edgeFunctionUrl}async makeEdgeFunctionRequest(e,s,t=null,a=null){if(!this.enabled)throw new Error("Upstash Redis edge function not available");const c={action:e,key:s};t!==null&&(c.value=t),a!==null&&(c.ttl=a);const o=await fetch(this.edgeFunctionUrl,{method:"POST",headers:{"Content-Type":"application/json",Authorization:"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndhcGJ3YWlta3VyYnVpaGF0bWl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkyODY3MjksImV4cCI6MjA3NDg2MjcyOX0.x-NQQ2TtRgaUjjBZCf6j49eWOW4XSqjTFKC_KB1L56A"},body:JSON.stringify(c)});if(!o.ok){const C=await o.json().catch(()=>({}));throw new Error(`Edge function error: ${o.status} ${C.message||"Unknown error"}`)}const d=await o.json();if(!d.success)throw new Error(`Redis operation failed: ${d.error}`);return d.result}async get(e,s=!0){try{if(this.enabled){const t=await this.makeEdgeFunctionRequest("get",e);if(t!==null)return await super.set(e,t),s?JSON.parse(t):t}return super.get(e,s)}catch(t){return i.warn("Upstash Redis get failed, using local cache:",t),super.get(e,s)}}async set(e,s,t=300){try{if(this.enabled){const a=typeof s=="string"?s:JSON.stringify(s);await this.makeEdgeFunctionRequest("set",e,a,t)}return await super.set(e,s,t),!0}catch(a){return i.warn("Upstash Redis set failed, using local cache only:",a),super.set(e,s,t)}}async del(e){try{this.enabled&&await this.makeEdgeFunctionRequest("del",e)}catch(s){i.warn("Upstash Redis del failed:",s)}return super.del(e)}async deletePattern(e){try{this.enabled&&await this.makeEdgeFunctionRequest("keys",e)}catch(s){i.warn("Upstash Redis deletePattern failed:",s)}return super.deletePattern(e)}async clear(){try{this.enabled&&await this.makeEdgeFunctionRequest("flush")}catch(e){i.warn("Upstash Redis clear failed:",e)}return super.clear()}async healthCheck(){try{if(this.enabled)return await this.makeEdgeFunctionRequest("ping"),{status:"healthy",message:"Upstash Redis edge function is responding",mode:"upstash-edge",timestamp:new Date().toISOString()}}catch(e){i.warn("Upstash Redis health check failed:",e)}return super.healthCheck()}}let z;X?z=new K:z=new H;const D=z,q={get:async r=>{if(!r)return null;try{return await D.get(r)}catch(e){return i.warn("Cache read error",{key:r,error:e.message,stack:e.stack}),null}},set:async(r,e,s=900)=>{if(r)try{await D.set(r,{data:e,timestamp:Date.now()},s)}catch(t){i.warn("Cache write error",{key:r,error:t.message,stack:t.stack})}},del:async r=>{if(!r)return!1;try{return await D.del(r),!0}catch(e){return i.warn("Cache delete error",{key:r,error:e.message,stack:e.stack}),!1}},invalidatePattern:async r=>{try{return await D.deletePattern(r),1}catch(e){return i.warn("Cache pattern invalidation error",{pattern:r,error:e.message,stack:e.stack}),0}}},W=60*1e3,Z=3,Q=1e3,J=(import.meta?.env?.VITE_REDIS_ENABLED||"").toString().toLowerCase()==="true",x=(r,e,s={})=>{const{ttl:t=300,dependencies:a=[],enabled:c=!0,staleTime:o=W,skipInitialFetch:d=!1,onSuccess:C,onError:b}=s,[f,u]=h.useState(null),[T,_]=h.useState(!d),[N,I]=h.useState(null),[M,j]=h.useState(!1),[$,O]=h.useState(null),[g,v]=h.useState(0),k=h.useRef(!0),w=h.useRef(null),l=h.useRef(!1),n=typeof r=="function"?r():r;h.useEffect(()=>()=>{k.current=!1,w.current?.abort()},[]);const R=h.useCallback(async(y=!1)=>{if(!(!n&&!y||!c)&&!l.current){l.current=!0,w.current=new AbortController;try{if(!y&&J){let S=null;try{S=await D.get(n)}catch(B){i.warn("Redis GET failed, continuing without cache",{key:n,error:B.message})}if(S){E.cacheHit();const B=!S.timestamp||Date.now()-new Date(S.timestamp).getTime()>o;if(k.current&&(u(S.data),j(B),O(S.timestamp?new Date(S.timestamp):new Date),_(!1),!y&&!B))return S.data}else E.cacheMiss()}k.current&&(_(!0),I(null));const m=performance.now(),p=await e(w.current.signal),A=performance.now();if(E.apiCall(A-m),!p)throw new Error("No response from server");const F={data:p,timestamp:new Date().toISOString(),metadata:{ttl:t,staleTime:o}};if(J)try{await D.set(n,F,t)}catch(S){i.warn("Redis SET failed, skipping cache write",{key:n,error:S.message})}return k.current&&(u(p),j(!1),O(new Date(F.timestamp)),_(!1),v(0),C?.(p)),p}catch(m){if(m.name==="AbortError")return;if(E.apiError(),i.error("Error in useRedisCache",{key:n,error:m.message,stack:m.stack}),k.current)if(I(m),_(!1),g<Z){const p=Q*Math.pow(2,g);setTimeout(()=>{k.current&&(v(A=>A+1),R(!0))},p)}else b?.(m);throw m}finally{l.current=!1,w.current=null}}},[n,e,t,o,c,g,C,b]);h.useEffect(()=>{if(!d)return R().catch(()=>{}),()=>w.current?.abort()},[n,d,R,...a]);const L=h.useCallback(async()=>{if(n){try{J&&await D.del(n),E.cacheDelete?.()}catch(y){i.warn("Redis DEL failed during invalidate",{key:n,error:y.message})}return R(!0)}},[n,R]),P=h.useCallback(y=>{n&&u(m=>{const p=typeof y=="function"?y(m):y,A={data:p,timestamp:new Date().toISOString(),metadata:{ttl:t,staleTime:o}};return J&&(async()=>{try{await D.set(n,A,t),E.cacheSet?.()}catch(F){i.warn("Redis SET failed during updateCache",{key:n,error:F.message})}})(),p})},[n,t,o]);return{data:f,error:N,loading:T,stale:M,lastUpdated:$,refetch:()=>R(!0),invalidate:L,updateCache:P,isStale:M,retryCount:g,cacheKey:n}},te=(r,e="student")=>x(`user:classes:${r}:${e}`,async()=>{try{if(e==="teacher"){const s=`
              id,
              name,
              description,
              subject,
              created_at,
              updated_at,
              created_by
          `,[{data:t,error:a},{data:c,error:o}]=await Promise.all([U.from("classes").select(s).eq("created_by",r),U.from("class_members").select("class_id").eq("user_id",r).eq("role","teacher")]);if(a)throw a;if(o)throw o;const d=(c||[]).map(f=>f.class_id);let C=[];if(d.length>0){const{data:f,error:u}=await U.from("classes").select(s).in("id",d);if(u)throw u;C=f||[]}const b=new Map;for(const f of[...t||[],...C])f&&!b.has(f.id)&&b.set(f.id,f);return Array.from(b.values())}else{const{data:s,error:t}=await U.from("class_members").select(`
              class_id,
              role,
              joined_at,
              classes (
                id,
                name,
                description,
                subject,
                created_at,
                updated_at
              )
            `).eq("user_id",r).eq("role",e);if(t)throw t;return s?.map(a=>({...a.classes,member_role:a.role,joined_at:a.joined_at}))||[]}}catch(s){return console.error("Error fetching user classes:",s),[]}},{ttl:10*60,dependencies:[r,e],enabled:!!r}),se=r=>x(`class:activities:${r}`,async()=>{const e=await fetch(`/api/classes/${r}/activities`);if(!e.ok)throw new Error("Failed to fetch class activities");return await e.json()},5*60),re=(r,e={})=>{const{enabled:s=!0,onActivityLoaded:t,onError:a,ttl:c=15*60,staleTime:o=60*1e3}=e,[d,C]=h.useState(!1),[b,f]=h.useState(null),u=r?`activity:details:${r}`:null,T=h.useCallback(async(g,v=!1)=>{if(!r||!s||!u)return null;const k=performance.now();let w=!1;try{if(!v){const L=await q.get(u);if(L){const{data:P,timestamp:y}=L,m=Date.now()-y;if(m<o)return E.cacheHit("activity_details"),w=!0,P;if(m<c*1e3)return E.cacheStale("activity_details"),w=!0,T(g,!0).catch(p=>{i.warn("Background refresh failed",{activityId:r,error:p.message})}),P}}const l=await fetch(`/api/activities/${r}`,{signal:g,headers:{"Cache-Control":"no-cache",Pragma:"no-cache"}});if(!l.ok){const L=new Error(`HTTP error! status: ${l.status}`);throw L.status=l.status,L}const n=await l.json(),R=performance.now();return await q.set(u,n,c),f(new Date().toISOString()),E.apiCall("activity_details",R-k,{cacheHit:w,fromCache:!1,activityId:r,status:"success"}),t&&!v&&t(n),n}catch(l){if(l.name!=="AbortError"){E.apiError("activity_details",l);const n={activityId:r,error:l.message,status:l.status,cacheHit:w,stack:l.stack};i.error("Failed to fetch activity details",n),a&&a(l,{cacheHit:w})}if(l.status===404&&await q.del(u),!v)throw l;return null}},[r,s,t,a,c,o,u]),_=h.useCallback(async()=>{if(!d)try{C(!0);const g=new AbortController;await T(g.signal,!0)}catch(g){i.warn("Background update failed",{activityId:r,error:g.message})}finally{C(!1)}},[r,T,d]),{data:N,loading:I,error:M,refetch:j,updateCache:$}=x(u,T,{...e,ttl:c,staleTime:o,enabled:s}),O=h.useCallback(async()=>u?q.del(u):!1,[u]);return{activity:N,loading:I||d,error:M,refetch:j,invalidateCache:O,updateCache:$,isBackgroundUpdating:d,lastUpdated:b,refreshInBackground:_}};export{re as a,se as b,te as u};
